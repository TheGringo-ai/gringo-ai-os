#!/usr/bin/env python3
"""
Test Generator Agent - Automated test creation and coverage analysis
"""

import json
import sys
import os
import ast
import subprocess
from datetime import datetime

class TestGeneratorAgent:
    def __init__(self):
        self.name = "test_gen"
        
    def analyze_test_coverage(self, workspace: str) -> dict:
        """Analyze existing test coverage"""
        
        source_files = []
        test_files = []
        
        for root, dirs, files in os.walk(workspace):
            if 'venv' in root or '__pycache__' in root:
                continue
                
            for file in files:
                if file.endswith('.py'):
                    file_path = os.path.join(root, file)
                    if 'test_' in file or file.endswith('_test.py'):
                        test_files.append(file_path)
                    else:
                        source_files.append(file_path)
        
        return {
            "source_files": len(source_files),
            "test_files": len(test_files),
            "coverage_ratio": len(test_files) / len(source_files) if source_files else 0,
            "uncovered_files": [f for f in source_files if not self._has_test_file(f, test_files)]
        }
    
    def _has_test_file(self, source_file: str, test_files: list) -> bool:
        """Check if source file has corresponding test"""
        base_name = os.path.basename(source_file).replace('.py', '')
        
        for test_file in test_files:
            if base_name in test_file or test_file.endswith(f'test_{base_name}.py'):
                return True
        return False
    
    def extract_functions_to_test(self, file_path: str) -> list:
        """Extract public functions that need tests"""
        functions = []
        
        try:
            with open(file_path, 'r') as f:
                content = f.read()
            
            tree = ast.parse(content)
            
            for node in ast.walk(tree):
                if isinstance(node, ast.FunctionDef):
                    # Skip private functions and main
                    if not node.name.startswith('_') and node.name != 'main':
                        functions.append({
                            "name": node.name,
                            "args": [arg.arg for arg in node.args.args],
                            "lineno": node.lineno,
                            "has_docstring": bool(ast.get_docstring(node))
                        })
                        
        except Exception as e:
            print(f"Error parsing {file_path}: {e}")
            
        return functions
    
    def generate_test_template(self, source_file: str, functions: list) -> str:
        """Generate test file template"""
        
        base_name = os.path.basename(source_file).replace('.py', '')
        module_name = base_name
        
        template = f'''#!/usr/bin/env python3
"""
Test file for {source_file}
Auto-generated by Test Generator Agent
"""

import unittest
import sys
import os

# Add parent directory to path for imports
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

import {module_name}

class Test{base_name.title()}(unittest.TestCase):
    """Test cases for {base_name}.py"""
    
    def setUp(self):
        """Set up test fixtures before each test method."""
        pass
    
    def tearDown(self):
        """Clean up after each test method."""
        pass
'''
        
        # Generate test methods for each function
        for func in functions:
            template += f'''
    def test_{func["name"]}(self):
        """Test {func["name"]} function"""
        # TODO: Implement test for {func["name"]}
        # Function signature: {func["name"]}({", ".join(func["args"])})
        self.skipTest("Test implementation needed")
'''
        
        template += '''
    def test_module_imports(self):
        """Test that module imports correctly"""
        try:
            import ''' + module_name + '''
            self.assertTrue(True)
        except ImportError as e:
            self.fail(f"Module import failed: {e}")

if __name__ == "__main__":
    unittest.main()
'''
        
        return template
    
    def create_test_files(self, workspace: str, uncovered_files: list) -> list:
        """Create test files for uncovered source files"""
        
        created_tests = []
        
        for source_file in uncovered_files:
            if 'agents/' in source_file or 'venv/' in source_file:
                continue
                
            functions = self.extract_functions_to_test(source_file)
            
            if functions:  # Only create test if there are functions to test
                base_name = os.path.basename(source_file).replace('.py', '')
                test_file_path = os.path.join(workspace, f'test_{base_name}.py')
                
                # Don't overwrite existing test files
                if not os.path.exists(test_file_path):
                    template = self.generate_test_template(source_file, functions)
                    
                    try:
                        with open(test_file_path, 'w') as f:
                            f.write(template)
                        
                        created_tests.append({
                            "source_file": source_file,
                            "test_file": test_file_path,
                            "functions_count": len(functions),
                            "functions": [f["name"] for f in functions]
                        })
                        
                    except Exception as e:
                        print(f"Failed to create test file {test_file_path}: {e}")
        
        return created_tests

def main():
    if len(sys.argv) < 2:
        print("❌ No task data provided")
        sys.exit(1)
    
    try:
        task_data = json.loads(sys.argv[1])
        agent = TestGeneratorAgent()
        
        print(f"🧪 Test Generator Agent: Analyzing test coverage...")
        
        workspace = task_data.get('workspace', '.')
        coverage_target = task_data.get('coverage_target', 70)
        
        coverage_analysis = agent.analyze_test_coverage(workspace)
        created_tests = agent.create_test_files(workspace, coverage_analysis['uncovered_files'])
        
        # Calculate new coverage estimate
        new_coverage = min(100, (coverage_analysis['test_files'] + len(created_tests)) / 
                          coverage_analysis['source_files'] * 100 if coverage_analysis['source_files'] > 0 else 100)
        
        result = {
            "coverage_analysis": coverage_analysis,
            "created_tests": created_tests,
            "target_coverage": coverage_target,
            "estimated_new_coverage": round(new_coverage, 1),
            "timestamp": datetime.now().isoformat(),
            "status": "completed"
        }
        
        print(f"✅ Test generation completed")
        print(f"   📊 Coverage: {coverage_analysis['coverage_ratio']:.1%} → {new_coverage:.1f}%")
        print(f"   🧪 Tests created: {len(created_tests)}")
        
        print(json.dumps(result, indent=2))
        
    except Exception as e:
        print(f"❌ Test generation failed: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
